package structpages

import (
	"context"
	"io"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
)

// Test page with error component
type renderTestErrorPage struct{}

func (e renderTestErrorPage) ErrorComponent(message string) component {
	return renderTestErrorComponent{message: message}
}

func (e renderTestErrorPage) NotFoundComponent(ignored string) component {
	return renderTestNotFoundComponent{}
}

type renderTestErrorComponent struct {
	message string
}

func (e renderTestErrorComponent) Render(ctx context.Context, w io.Writer) error {
	_, err := w.Write([]byte("<div class=\"error\">" + e.message + "</div>"))
	return err
}

type renderTestNotFoundComponent struct{}

func (n renderTestNotFoundComponent) Render(ctx context.Context, w io.Writer) error {
	_, err := w.Write([]byte("<div class=\"not-found\">Page not found</div>"))
	return err
}

// Test page that conditionally renders error components
type renderTestConditionalPage struct{}

func (c renderTestConditionalPage) Props(r *http.Request) (string, error) {
	trigger := r.URL.Query().Get("trigger")
	switch trigger {
	case "error":
		return "", RenderPageComponent(&renderTestErrorPage{}, "ErrorComponent", "Something went wrong")
	case "notfound":
		return "", RenderPageComponent(&renderTestErrorPage{}, "NotFoundComponent")
	default:
		return "success", nil
	}
}

func (c renderTestConditionalPage) Page(message string) component {
	return renderTestSuccessComponent{message: message}
}

type renderTestSuccessComponent struct {
	message string
}

func (s renderTestSuccessComponent) Render(ctx context.Context, w io.Writer) error {
	_, err := w.Write([]byte("<div class=\"success\">" + s.message + "</div>"))
	return err
}

// Test RenderPageComponent normal rendering
func TestRenderPageComponent_Normal(t *testing.T) {
	type pages struct {
		renderTestConditionalPage `route:"/test"`
		renderTestErrorPage       `route:"/error"`
	}

	sp := New()
	router := NewRouter(http.NewServeMux())

	if err := sp.MountPages(router, &pages{}, "/", "Test"); err != nil {
		t.Fatalf("MountPages failed: %v", err)
	}

	req := httptest.NewRequest(http.MethodGet, "/test", nil)
	rec := httptest.NewRecorder()
	router.ServeHTTP(rec, req)

	if rec.Code != http.StatusOK {
		t.Errorf("expected status %d, got %d", http.StatusOK, rec.Code)
	}

	body := rec.Body.String()
	expected := "<div class=\"success\">success</div>"
	if body != expected {
		t.Errorf("expected body %q, got %q", expected, body)
	}
}

// Test RenderPageComponent with error component
func TestRenderPageComponent_Error(t *testing.T) {
	type pages struct {
		renderTestConditionalPage `route:"/test"`
		renderTestErrorPage       `route:"/error"`
	}

	sp := New()
	router := NewRouter(http.NewServeMux())

	if err := sp.MountPages(router, &pages{}, "/", "Test"); err != nil {
		t.Fatalf("MountPages failed: %v", err)
	}

	req := httptest.NewRequest(http.MethodGet, "/test?trigger=error", nil)
	rec := httptest.NewRecorder()
	router.ServeHTTP(rec, req)

	if rec.Code != http.StatusOK {
		t.Errorf("expected status %d, got %d", http.StatusOK, rec.Code)
	}

	body := rec.Body.String()
	expected := "<div class=\"error\">Something went wrong</div>"
	if body != expected {
		t.Errorf("expected body %q, got %q", expected, body)
	}
}

// Test RenderPageComponent with not found component
func TestRenderPageComponent_NotFound(t *testing.T) {
	type pages struct {
		renderTestConditionalPage `route:"/test"`
		renderTestErrorPage       `route:"/error"`
	}

	sp := New()
	router := NewRouter(http.NewServeMux())

	if err := sp.MountPages(router, &pages{}, "/", "Test"); err != nil {
		t.Fatalf("MountPages failed: %v", err)
	}

	req := httptest.NewRequest(http.MethodGet, "/test?trigger=notfound", nil)
	rec := httptest.NewRecorder()
	router.ServeHTTP(rec, req)

	if rec.Code != http.StatusOK {
		t.Errorf("expected status %d, got %d", http.StatusOK, rec.Code)
	}

	body := rec.Body.String()
	expected := "<div class=\"not-found\">Page not found</div>"
	if body != expected {
		t.Errorf("expected body %q, got %q", expected, body)
	}
}

// Test multiple arguments
type multiArgPage struct{}

func (m multiArgPage) MultiComponent(name string, count int, enabled bool) component {
	return multiArgComponent{name: name, count: count, enabled: enabled}
}

type multiArgComponent struct {
	name    string
	count   int
	enabled bool
}

func (m multiArgComponent) Render(ctx context.Context, w io.Writer) error {
	status := "disabled"
	if m.enabled {
		status = "enabled"
	}
	content := "<div>" + m.name + " count:" + string(rune(m.count+'0')) + " status:" + status + "</div>"
	_, err := w.Write([]byte(content))
	return err
}

type multiArgTestPage struct{}

func (m multiArgTestPage) Props(r *http.Request) (string, error) {
	return "", RenderPageComponent(&multiArgPage{}, "MultiComponent", "test", 5, true)
}

func (m multiArgTestPage) Page(message string) component {
	return renderTestSuccessComponent{message: message}
}

// Test RenderPageComponent with multiple arguments
func TestRenderPageComponentMultipleArgs(t *testing.T) {
	type pages struct {
		multiArgTestPage `route:"/multitest"`
		multiArgPage     `route:"/multi"`
	}

	sp := New()
	router := NewRouter(http.NewServeMux())

	if err := sp.MountPages(router, &pages{}, "/", "Test"); err != nil {
		t.Fatalf("MountPages failed: %v", err)
	}

	req := httptest.NewRequest(http.MethodGet, "/multitest", nil)
	rec := httptest.NewRecorder()
	router.ServeHTTP(rec, req)

	if rec.Code != http.StatusOK {
		t.Errorf("expected status %d, got %d", http.StatusOK, rec.Code)
	}

	expectedBody := "<div>test count:5 status:enabled</div>"
	body := rec.Body.String()
	if body != expectedBody {
		t.Errorf("expected body %q, got %q", expectedBody, body)
	}
}

// Test error handling when page not found
type invalidPageTestPage struct{}

func (i invalidPageTestPage) Props(r *http.Request) (string, error) {
	// Reference a page that doesn't exist in the router
	return "", RenderPageComponent(&struct{}{}, "SomeComponent")
}

func (i invalidPageTestPage) Page(message string) component {
	return renderTestSuccessComponent{message: message}
}

// Test RenderPageComponent with invalid page
func TestRenderPageComponentInvalidPage(t *testing.T) {
	type pages struct {
		invalidPageTestPage `route:"/invalid"`
	}

	var capturedError error
	errorHandler := func(w http.ResponseWriter, r *http.Request, err error) {
		capturedError = err
		http.Error(w, err.Error(), http.StatusInternalServerError)
	}

	sp := New(WithErrorHandler(errorHandler))
	router := NewRouter(http.NewServeMux())

	if err := sp.MountPages(router, &pages{}, "/", "Test"); err != nil {
		t.Fatalf("MountPages failed: %v", err)
	}

	req := httptest.NewRequest(http.MethodGet, "/invalid", nil)
	rec := httptest.NewRecorder()
	router.ServeHTTP(rec, req)

	if rec.Code != http.StatusInternalServerError {
		t.Errorf("expected status %d, got %d", http.StatusInternalServerError, rec.Code)
	}

	if capturedError == nil {
		t.Error("expected error to be captured")
	} else {
		expectedErrorSubstring := "findPageNode: no page node found"
		if !strings.Contains(capturedError.Error(), expectedErrorSubstring) {
			t.Errorf("expected error to contain %q, got %q", expectedErrorSubstring, capturedError.Error())
		}
	}
}

// Test error handling when component not found
type invalidComponentTestPage struct{}

func (i invalidComponentTestPage) Props(r *http.Request) (string, error) {
	return "", RenderPageComponent(&renderTestErrorPage{}, "NonExistentComponent")
}

func (i invalidComponentTestPage) Page(message string) component {
	return renderTestSuccessComponent{message: message}
}

// Test RenderPageComponent with invalid component
func TestRenderPageComponentInvalidComponent(t *testing.T) {
	type pages struct {
		invalidComponentTestPage `route:"/invalidcomp"`
		renderTestErrorPage      `route:"/error"`
	}

	var capturedError error
	errorHandler := func(w http.ResponseWriter, r *http.Request, err error) {
		capturedError = err
		http.Error(w, err.Error(), http.StatusInternalServerError)
	}

	sp := New(WithErrorHandler(errorHandler))
	router := NewRouter(http.NewServeMux())

	if err := sp.MountPages(router, &pages{}, "/", "Test"); err != nil {
		t.Fatalf("MountPages failed: %v", err)
	}

	req := httptest.NewRequest(http.MethodGet, "/invalidcomp", nil)
	rec := httptest.NewRecorder()
	router.ServeHTTP(rec, req)

	if rec.Code != http.StatusInternalServerError {
		t.Errorf("expected status %d, got %d", http.StatusInternalServerError, rec.Code)
	}

	if capturedError == nil {
		t.Error("expected error to be captured")
	} else {
		expectedErrorSubstring := "component NonExistentComponent not found"
		if !strings.Contains(capturedError.Error(), expectedErrorSubstring) {
			t.Errorf("expected error to contain %q, got %q", expectedErrorSubstring, capturedError.Error())
		}
	}
}

// Test RenderPageComponent with different component methods
type componentVariationsPage struct{}

func (c componentVariationsPage) Props(r *http.Request) (string, error) {
	component := r.URL.Query().Get("component")
	switch component {
	case "header":
		return "", RenderPageComponent(&headerPage{}, "Page")
	case "footer":
		return "", RenderPageComponent(&footerPage{}, "Page", "Â© 2024")
	default:
		return "default", nil
	}
}

func (c componentVariationsPage) Page(message string) component {
	return renderTestSuccessComponent{message: message}
}

type headerPage struct{}

func (h headerPage) Page(ignored string) component {
	return headerComponent{}
}

type footerPage struct{}

func (f footerPage) Page(text string) component {
	return footerComponent{text: text}
}

type headerComponent struct{}

func (h headerComponent) Render(ctx context.Context, w io.Writer) error {
	_, err := w.Write([]byte("<header>Site Header</header>"))
	return err
}

type footerComponent struct {
	text string
}

func (f footerComponent) Render(ctx context.Context, w io.Writer) error {
	_, err := w.Write([]byte("<footer>" + f.text + "</footer>"))
	return err
}

// Test RenderPageComponent with header component
func TestRenderPageComponentSharedComponents_Header(t *testing.T) {
	type pages struct {
		componentVariationsPage `route:"/shared"`
		headerPage              `route:"/header"`
		footerPage              `route:"/footer"`
	}

	sp := New()
	router := NewRouter(http.NewServeMux())

	if err := sp.MountPages(router, &pages{}, "/", "Test"); err != nil {
		t.Fatalf("MountPages failed: %v", err)
	}

	req := httptest.NewRequest(http.MethodGet, "/shared?component=header", nil)
	rec := httptest.NewRecorder()
	router.ServeHTTP(rec, req)

	if rec.Code != http.StatusOK {
		t.Errorf("expected status %d, got %d", http.StatusOK, rec.Code)
	}

	body := rec.Body.String()
	expected := "<header>Site Header</header>"
	if body != expected {
		t.Errorf("expected body %q, got %q", expected, body)
	}
}

// Test RenderPageComponent with footer component
func TestRenderPageComponentSharedComponents_Footer(t *testing.T) {
	type pages struct {
		componentVariationsPage `route:"/shared"`
		headerPage              `route:"/header"`
		footerPage              `route:"/footer"`
	}

	var capturedError error
	errorHandler := func(w http.ResponseWriter, r *http.Request, err error) {
		capturedError = err
		http.Error(w, err.Error(), http.StatusInternalServerError)
	}

	sp := New(WithErrorHandler(errorHandler))
	router := NewRouter(http.NewServeMux())

	if err := sp.MountPages(router, &pages{}, "/", "Test"); err != nil {
		t.Fatalf("MountPages failed: %v", err)
	}

	req := httptest.NewRequest(http.MethodGet, "/shared?component=footer", nil)
	rec := httptest.NewRecorder()
	capturedError = nil
	router.ServeHTTP(rec, req)

	if rec.Code != http.StatusOK {
		t.Errorf("expected status %d, got %d", http.StatusOK, rec.Code)
		if capturedError != nil {
			t.Errorf("captured error: %v", capturedError)
		}
	}

	body := rec.Body.String()
	expected := "<footer>Â© 2024</footer>"
	if body != expected {
		t.Errorf("expected body %q, got %q", expected, body)
		if capturedError != nil {
			t.Errorf("captured error: %v", capturedError)
		}
	}
}
